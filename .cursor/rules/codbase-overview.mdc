---
alwaysApply: true
---
# Thread System Architecture

## CRITICAL: Thread-First Design

**Everything is a thread**. Single posts are threads with one tweet. This unified approach eliminates special cases and simplifies the entire codebase.

### Core Principles

1. **Thread Identity**: All tweets sharing a `threadId` belong together
2. **Position-Based Order**: `position` field (0-based) determines tweet order
3. **Single Posts**: Have `threadId` === `id` and `position` = 0
4. **Edit = Replace**: Updates delete and recreate all tweets in thread
5. **Soft Delete**: Posts marked as `isPosted`, never actually deleted

## Database Schema

### tweets Table Structure
```typescript
{
  id: UUID                    // Unique tweet identifier
  threadId: UUID             // Groups tweets (same for all in thread)
  position: number           // Order within thread (0, 1, 2...)
  content: string            // Tweet text
  media: JSON[]              // [{s3Key, media_id, url, type}]
  isThreadStart: boolean     // true only for position 0
  isScheduled: boolean       // Has scheduling info
  scheduledFor: Date         // When to post (user timezone)
  scheduledUnix: bigint      // Unix ms for sorting
  qstashId: string          // QStash message ID
  isPosted: boolean         // Already posted to Twitter/X
  postedAt: Date            // When actually posted
  tweetId: string           // Twitter's ID after posting
  delayMs: number           // Delay before next tweet
}
```

## Component Architecture

### Frontend Components

#### ThreadTweetEditor (`thread-tweet-editor.tsx`)
Main container managing thread state and API calls:
```typescript
// State shape
threadTweets: Array<{
  id: string      // Client-side UUID
  content: string // Tweet text
  media: Array<{  // Media attachments
    s3Key: string
    media_id: string
    url: string
    type: 'image' | 'gif' | 'video'
  }>
}>

// Key mutations
createThreadMutation → POST /api/tweet/createThread
updateThreadMutation → POST /api/tweet/updateThread
postThreadMutation → POST /api/tweet/postThreadNow
enqueueThreadMutation → POST /api/tweet/enqueueThread
scheduleThreadMutation → POST /api/tweet/scheduleThread
```

#### ThreadTweet (`thread-tweet.tsx`)
Individual tweet component with rich text editor:
- Lexical editor for content
- Media upload via ImageTool
- Character counting
- @mention support
- Action buttons (only on first tweet)

### API Endpoints (`tweet-router.ts`)

#### Core CRUD
```typescript
createThread({ tweets: [{content, media, delayMs}] })
→ Creates all tweets with same threadId

updateThread({ threadId, tweets: [...] })
→ Deletes existing, creates new with same threadId

deleteThread({ threadId })
→ Removes all tweets, cancels QStash job

getThread({ id }) // Actually threadId
→ Returns all tweets ordered by position
```

#### Posting Actions
```typescript
postThreadNow({ threadId })
→ Uploads media to Twitter, posts sequentially

enqueueThread({ threadId, userNow, timezone })
→ Finds next slot (10am/12pm/2pm), schedules via QStash

scheduleThread({ threadId, scheduledUnix })
→ Manual scheduling for specific timestamp
```

#### Data Fetching
```typescript
get_queue({ timezone, userNow })
→ Returns queued posts grouped by thread

getScheduledAndPublished({ filter: 'posted'|'scheduled' })
→ Unified endpoint for all content, always thread-grouped
```

## Media Flow

### Upload Process
1. **Select File** → `POST /api/file/upload` → S3
2. **Store Reference** → `{s3Key: "uploads/xyz.jpg"}`
3. **On Post** → Fetch from S3 → Upload to Twitter → Get `media_id`
4. **Update DB** → Add `media_id` to existing record

### Media Structure Evolution
```typescript
// During creation/edit
{ s3Key: "uploads/img.jpg", url: "https://...", type: "image" }

// After posting  
{ s3Key: "uploads/img.jpg", media_id: "123456", url: "https://...", type: "image" }
```

## Queue System

### Slot Algorithm
```typescript
const SLOTS = [10, 12, 14] // 10am, 12pm, 2pm
// Find next available slot not already occupied
// Skip weekends if user preference set
// Return { time: Date, dayName: string }
```

### QStash Integration
```typescript
qstash.publishJSON({
  url: process.env.WEBHOOK_URL || getBaseUrl() + '/api/tweet/postThread',
  body: { threadId, userId, accountId },
  notBefore: scheduledUnix  // Seconds, not milliseconds!
})
```

## State Management

### React Query Keys
```typescript
['thread', threadId]                    // Single thread data
['threads-queue']                       // All queued posts
['threads-scheduled-published']         // All scheduled/posted
['threads-posted', account.username]    // User's posted content
```

### Cache Invalidation Pattern
```typescript
// After any mutation
queryClient.invalidateQueries({ queryKey: ['thread'] })
queryClient.invalidateQueries({ queryKey: ['threads-queue'] })
```

## Common Patterns

### Creating a Thread
```typescript
// Single post
createThread({ tweets: [{ content: "Hello", media: [], delayMs: 0 }] })

// Multi-tweet thread  
createThread({ tweets: [
  { content: "Tweet 1", media: [], delayMs: 0 },
  { content: "Tweet 2", media: [], delayMs: 1000 },
  { content: "Tweet 3", media: [], delayMs: 1000 }
]})
```

### Edit Mode Flow
```typescript
// URL: /studio?edit=true&tweetId=[threadId]
1. Detect edit mode from query params
2. Fetch thread: getThreadQuery(threadId)  
3. Populate editor with content and media
4. On save: updateThread preserves scheduling
```

### Media in Edit Mode
```typescript
// WRONG - Loses media on edit
initialMedia={[]}

// CORRECT - Preserves existing media
initialMedia={tweet.media?.map(m => ({
  url: m.url || '',
  s3Key: m.s3Key,
  media_id: m.media_id,
  type: m.type || 'image'
})) || []}
```

## Critical Rules

### NEVER Do These
- Mix tweets from different threads (always check threadId)
- Assume single tweets have special handling (they're 1-tweet threads)
- Store media in database (use S3 references only)
- Use milliseconds for QStash (it expects seconds)
- Delete posted tweets (mark as posted instead)

### ALWAYS Do These
- Group all operations by threadId
- Order tweets by position field
- Invalidate caches after mutations
- Convert timestamps to user timezone for display
- Handle media as array even for single images

## Debug Checklist

**Thread not showing?**
- Verify all tweets have same threadId
- Check isScheduled/isPosted flags
- Confirm scheduledFor is set

**Media missing on edit?**
- Check initialMedia prop mapping
- Verify S3 URLs are accessible
- Confirm media array structure

**Scheduling failed?**
- QStash expects seconds, not milliseconds
- Webhook URL must be publicly accessible
- Check QStash dashboard for errors

**Wrong order?**
- Always ORDER BY position, not timestamp
- Position is 0-based (0, 1, 2...)
- First tweet must have isThreadStart=true

## Deployment Configuration

### CRITICAL: Vercel Deployment First

**All code must be designed for Vercel deployment, not local development**. This application is built specifically for production deployment on Vercel's serverless platform.

### Deployment Requirements

- **Environment Variables**: All configuration must use Vercel environment variables, not local `.env` files
- **Serverless Functions**: All API routes are serverless functions with proper timeout and memory configurations
- **Database Connections**: Use connection pooling and handle cold starts appropriately
- **File Storage**: All file uploads go to S3, never local filesystem
- **Background Jobs**: Use QStash for scheduled tasks, not local cron jobs
- **Build Process**: Code must compile successfully on Vercel's build environment
- **Edge Compatibility**: Consider Vercel Edge Runtime limitations when applicable

### Forbidden Patterns for Deployment

- Local file system operations (use S3 instead)
- Long-running processes (use QStash for background jobs)
- Local database connections without pooling
- Hardcoded localhost URLs
- Environment-specific code that only works locally

### Required Patterns for Deployment

- Dynamic base URL detection: `getBaseUrl()` function
- Proper error handling for serverless cold starts
- Connection pooling for database operations
- Environment variable validation
- Webhook URLs that work in production

**Always test functionality with deployment in mind, not just local development**
